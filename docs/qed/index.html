<html>
<head>
  <title>Ruby ANSI</title>

  <!-- TODO: most of the css before the '*' can be removed. -->

  <style>
    #container{ margin: 0 auto; width: 800px; }

    /* Debug borders */
    /* p, li, dt, dd, div, pre, h1, h2, h3, h4, h5, h6 { border: 1px solid red; } */

    body { font-size: 14px; line-height: 20px; margin: 1em 5% 1em 5%; font-family: Verdana, Arial, Helvetica, sans-serif; }
    a { color: #336; text-decoration: underline; }
    a:visited { color: #334; }
    em { font-style: italic; }
    strong { font-weight: bold; }
    tt { color: navy; }

    h1, h2, h3, h4, h5, h6 { color: #223; margin-top: 1.2em; margin-bottom: 0.5em; line-height: 1.3; }
    h1 { border-bottom: 2px solid silver; }
    h2 { border-bottom: 2px solid silver; padding-top: 0.5em; }

    hr { color: #ccc; margin-top: 1.6em; }

    p { color: #222; text-align: justify; margin-top: 0.5em; margin-bottom: 0.5em; line-height: 1.4em; }

    /* pre { padding: 10; margin: 0; font-family: monospace; font-size: 0.9em; } */

    pre.pass { color: green; }
    pre.fail { color: red; }
    pre.error { color: red; font-weight: bold; }

    span#author { color: #527bbd; font-weight: bold; font-size: 1.1em; }
    span#email { }
    span#revision { }

    div#footer { font-size: small; border-top: 2px solid silver; padding-top: 0.5em; margin-top: 4.0em; }
    div#footer-text { float: left; padding-bottom: 0.5em; }
    div#footer-badges { float: right; padding-bottom: 0.5em; }

    /* Block element content. */
    div.content { padding: 0; }

    /* Block element titles. */
    h1.title { font-weight: bold; text-align: left; font-size: 3em; margin-top: 1.0em; margin-bottom: 0.5em; }

    /* Block element titles. */
    div.title, caption.title { font-weight: bold; text-align: left; margin-top: 1.0em; margin-bottom: 0.5em; }
    div.title + * { margin-top: 0; }
    td div.title:first-child { margin-top: 0.0em; }
    div.content div.title:first-child { margin-top: 0.0em; }
    div.content + div.title { margin-top: 0.0em; }
    div.sidebarblock > div.content { background: #ffffee; border: 1px solid silver; padding: 0.5em; }

    img { border-style: none; }

    dl { margin-top: 0.8em; margin-bottom: 0.8em; }
    dt { margin-top: 0.5em; margin-bottom: 0; font-style: italic; }
    dd > *:first-child { margin-top: 0; }
    ul, ol { list-style-position: outside; }

    thead { font-weight: bold; }
    tfoot { font-weight: bold; }

    *{margin:0;padding:0;}
    html,body{height:100%;color:black;}
    body{background-color:white;font:13.34px helvetica,arial,freesans,clean,sans-serif;*font-size:small;}
    table{font-size:inherit;font:100%;}
    select,input[type=text],input[type=password],input[type=image],textarea{font:99% helvetica,arial,freesans,sans-serif;}
    select,option{padding:0 .25em;}
    optgroup{margin-top:.5em;}
    input.text{padding:1px 0;}
    pre,code{font:12px Monaco,"Courier New","DejaVu Sans Mono","Bitstream Vera Sans Mono",monospace;}
    body *{line-height:1.4em;}
    p{margin:1em 0;}
    img{border:0;}
    abbr{border-bottom:none;}

    .wikistyle h1,.wikistyle h2,.wikistyle h3,.wikistyle h4,.wikistyle h5,.wikistyle h6{border:0!important;}
    .wikistyle h1{font-size:170%!important;border-top:4px solid #aaa!important;padding-top:.5em!important;margin-top:1.5em!important;}
    .wikistyle h1:first-child{margin-top:0!important;padding-top:.25em!important;border-top:none!important;}
    .wikistyle h2{font-size:150%!important;margin-top:1.5em!important;border-top:4px solid #e0e0e0!important;padding-top:.5em!important;}
    .wikistyle h3{margin-top:1em!important;}
    .wikistyle p{margin:1em 0!important;line-height:1.5em!important;}
    .wikistyle ul{margin:1em 0 1em 2em!important;}
    .wikistyle ol{margin:1em 0 1em 2em!important;}
    .wikistyle ul ul,.wikistyle ul ol,.wikistyle ol ol,.wikistyle ol ul{margin-top:0!important;margin-bottom:0!important;}
    .wikistyle blockquote{margin:1em 0!important;border-left:5px solid #ddd!important;padding-left:.6em!important;color:#555!important;}
    .wikistyle dt{font-weight:bold!important;margin-left:1em!important;}
    .wikistyle dd{margin-left:2em!important;margin-bottom:1em!important;}
    .wikistyle table{margin:1em 0!important;}
    .wikistyle table th{border-bottom:1px solid #bbb!important;padding:.2em 1em!important;}
    .wikistyle table td{border-bottom:1px solid #ddd!important;padding:.2em 1em!important;}
    .wikistyle pre{margin:1em 0!important;font-size:90%!important;background-color:#f8f8ff!important;border:1px solid #dedede!important;padding:.5em!important;line-height:1.5em!important;color:#444!important;overflow:auto!important;}
    .wikistyle pre code{padding:0!important;font-size:100%!important;background-color:#f8f8ff!important;border:none!important;}
    .wikistyle code{font-size:90%!important;background-color:#f8f8ff!important;color:#444!important;padding:0 .2em!important;border:1px solid #dedede!important;}
    .wikistyle pre.console{margin:1em 0!important;font-size:90%!important;background-color:black!important;padding:.5em!important;line-height:1.5em!important;color:white!important;}
    .wikistyle pre.console code{padding:0!important;font-size:100%!important;background-color:black!important;border:none!important;color:white!important;}
    .wikistyle pre.console span{color:#888!important;}
    .wikistyle pre.console span.command{color:yellow!important;}

    .title { font-size: 2em; }
  </style>

  <!-- TODO: only include if these files exists -->
  <link href="../assets/styles/spec.css" type="text/css" rel="stylesheet">
  <!-- spec.css might be a problem with clobber -->
  <link href="spec.css" type="text/css" rel="stylesheet">

  

  <!-- JQuery is needed -->
  <script src="jquery.js" type="text/javascript" language="javascript"></script>

</head>

<body class="wikistyle">

  <!-- Side Table of Contents -->
  <div id="sidebar" style="position: fixed; top: 10; right: 10; background: white;">
    <a href="javascript: toc_toggle();">
      <img src="img/icon/book.jpg" height="30px;" style="border: none;" alt="TOC" align="right"/>
    </a>

    <div id="toc_side" class="toc">
    </div>
  </div>

  <div id="container">
    <div id="header">
      <img src="img/icon/book.jpg" align="left" style="padding-right: 10px;" alt=""/>

      <div class="title">Ruby ANSI</div>

      <h1>Table of Contents</h1>

      <div class="toc">
      </div>
    </div>

    <div id="content">
      
<h1>ANSI::Code</h1>

<p>Require the library.</p>

<pre>require 'ansi/code'</pre>

<p>ANSI::Code can be used as a functions module.</p>

<pre>str = ANSI::Code.red + &quot;Hello&quot; + ANSI::Code.blue + &quot;World&quot;
str.assert == &quot;\e[31mHello\e[34mWorld&quot;</pre>

<p>If a block is supplied to each method then yielded value will be wrapped in
the ANSI code and clear code.</p>

<pre>str = ANSI::Code.red{ &quot;Hello&quot; } + ANSI::Code.blue{ &quot;World&quot; }
str.assert == &quot;\e[31mHello\e[0m\e[34mWorld\e[0m&quot;</pre>

<p>More conveniently the ANSI::Code module extends ANSI itself.</p>

<pre>str = ANSI.red + &quot;Hello&quot; + ANSI.blue + &quot;World&quot;
str.assert == &quot;\e[31mHello\e[34mWorld&quot;

str = ANSI.red{ &quot;Hello&quot; } + ANSI.blue{ &quot;World&quot; }
str.assert == &quot;\e[31mHello\e[0m\e[34mWorld\e[0m&quot;</pre>

<p>In the appropriate context the ANSI::Code module can also be included,
making its methods directly accessible.</p>

<pre>include ANSI::Code

str = red + &quot;Hello&quot; + blue + &quot;World&quot;
str.assert == &quot;\e[31mHello\e[34mWorld&quot;

str = red{ &quot;Hello&quot; } + blue{ &quot;World&quot; }
str.assert == &quot;\e[31mHello\e[0m\e[34mWorld\e[0m&quot;</pre>

<p>Along with the single font colors, the library include background colors.</p>

<pre>str = on_red + &quot;Hello&quot;
str.assert == &quot;\e[41mHello&quot;</pre>

<p>As well as combined color methods.</p>

<pre>str = white_on_red + &quot;Hello&quot;
str.assert == &quot;\e[37m\e[41mHello&quot;</pre>

<p>In addition the library offers an extension to String class called #ansi,
which allows some of the ANSI::Code methods to be called in a more
object-oriented fashion.</p>

<pre>str = &quot;Hello&quot;.ansi(:red) + &quot;World&quot;.ansi(:blue)
str.assert == &quot;\e[31mHello\e[0m\e[34mWorld\e[0m&quot;</pre>

<p>The ANSI::Code module supports most standard ANSI codes, though not all
platforms support every code, so YMMV.</p>


<h1>ANSI::BBCode</h1>

<p>The BBCode module provides methods for converting between BBCodes, basic
HTML and ANSI codes.</p>

<pre>require 'ansi/bbcode'</pre>

<p>BBCodes are color and style codes in square brackets, quite popular with on
line forums.</p>

<pre>bbcode = &quot;this is [COLOR=red]red[/COLOR], this is [B]bold[/B]&quot;</pre>

<p>We can convert this to ANSI code simply enough:</p>

<pre>ansi = ANSI::BBCode.bbcode_to_ansi(bbcode)

ansi.assert == &quot;this is \e[0;31mred\e[0m, this is \e[1mbold\e[0m\n&quot;</pre>

<p>In addition the BBCode module supports conversion to simple HTML.</p>

<pre>html = ANSI::BBCode.bbcode_to_html(bbcode)

html.assert == &quot;this is &lt;font color=\&quot;red\&quot;&gt;red&lt;/font&gt;, this is &lt;strong&gt;bold&lt;/strong&gt;&lt;br /&gt;\n&quot;</pre>


<h1>ANSI::Logger</h1>

<p>Require the ANSI::Logger library.</p>

<pre>require 'ansi/logger'</pre>

<p>Create a new ANSI::Logger</p>

<pre>log = ANSI::Logger.new(STDOUT)</pre>

<p>Info logging appears normal.</p>

<pre>log.info{&quot;Info logs are green.\n&quot;}</pre>

<p>Warn logging appears yellow.</p>

<pre>log.warn{&quot;Warn logs are yellow.\n&quot;}</pre>

<p>Debug logging appears cyan.</p>

<pre>log.debug{&quot;Debug logs are cyan.\n&quot;}</pre>

<p>Error logging appears red.</p>

<pre>log.error{&quot;Error logs are red.\n&quot;}</pre>

<p>Fatal logging appears bright red.</p>

<pre>log.fatal{&quot;Fatal logs are bold red!\n&quot;}</pre>

<p>QED.</p>


<h1>ANSI::Progressbar</h1>

<p>Pretty progress bars are easy to construct.</p>

<pre>require 'ansi/progressbar'

pbar = ANSI::Progressbar.new(&quot;Test Bar&quot;, 100)</pre>

<p>Running the bar simply requires calling the #inc method during a loop and
calling #finish when done.</p>

<pre>100.times do |i|
  sleep 0.01
  pbar.inc
end
pbar.finish</pre>

<p>We will use this same rountine in all the examples below, so lets make a
quick macro for it. Notice we have to use #reset first before reusing the
same progress bar.</p>

<pre>def run(pbar)
  pbar.reset
  100.times do |i|
    sleep 0.01
    pbar.inc
  end
  pbar.finish
  puts
end</pre>

<p>The progress bar can be stylized in almost any way. The #format setter
provides control over the parts that appear on the line. For example, by
default the format is:</p>

<pre>pbar.format(&quot;%-14s %3d%% %s %s&quot;, :title, :percentage, :bar, :stat)</pre>

<p>So lets vary it up to demonstrate the case.</p>

<pre>pbar.format(&quot;%-14s %3d%% %s %s&quot;, :title, :percentage, :stat, :bar)
run(pbar)</pre>

<p>The progress bar has an extra build in format intended for use with file
downloads called #transer_mode.</p>

<pre>pbar.transfer_mode
run(pbar)</pre>

<p>Calling this methods is the same as calling:</p>

<pre>pbar.format(&quot;%-14s %3d%% %s %s&quot;,:title, :percentage, :bar, :stat_for_file_transfer)
run(pbar)</pre>

<p>The #style setter allows each part of the line be modified with ANSI codes.
And the #bar_mark writer can be used to change the character used to make
the bar.</p>

<pre>pbar.standard_mode
pbar.style(:title =&gt; [:red], :bar=&gt;[:blue])
pbar.bar_mark = &quot;=&quot;
run(pbar)</pre>

<p>QED.</p>


<h1>ANSI::Mixin</h1>

<p>The ANSI::Mixin module is design for including into String-like classes. It
will support any class that defines a #to_s method.</p>

<pre>require 'ansi/mixin'</pre>

<p>In this demonstration we will simply include it in the core String class.</p>

<pre>class ::String
  include ANSI::Mixin
end</pre>

<p>Now all strings will have access to ANSI’s style and color codes via
simple method calls.</p>

<pre>&quot;roses&quot;.red.assert == &quot;\e[31mroses\e[0m&quot;

&quot;violets&quot;.blue.assert == &quot;\e[34mviolets\e[0m&quot;

&quot;sugar&quot;.italic.assert == &quot;\e[3msugar\e[0m&quot;</pre>

<p>The method can be combined, of course.</p>

<pre>&quot;you&quot;.italic.bold.assert == &quot;\e[1m\e[3myou\e[0m\e[0m&quot;</pre>

<p>The mixin also supports background methods.</p>

<pre>&quot;envy&quot;.on_green.assert == &quot;\e[42menvy\e[0m&quot;</pre>

<p>And it also supports the combined foreground-on-background  methods.</p>

<pre>&quot;b&amp;w&quot;.white_on_black.assert == &quot;\e[37m\e[40mb&amp;w\e[0m&quot;</pre>


<h1>ANSI::String</h1>

<p>The ANSI::String class is a very sophisticated implementation of Ruby’s
standard String class, but one that can handle ANSI codes seamlessly.</p>

<pre>require 'ansi/string'

flower1 = ANSI::String.new(&quot;Roses&quot;)
flower2 = ANSI::String.new(&quot;Violets&quot;)</pre>

<p>Like any other string.</p>

<pre>flower1.to_s.assert == &quot;Roses&quot;
flower2.to_s.assert == &quot;Violets&quot;</pre>

<p>Bet now we can add color.</p>

<pre>flower1.red!
flower2.blue!

flower1.to_s.assert == &quot;\e[31mRoses\e[0m&quot;
flower2.to_s.assert == &quot;\e[34mViolets\e[0m&quot;</pre>

<p>Despite that the string representation now contains ANSI codes, we can
still manipulate the string in much the same way that we manipulate an
ordinary string.</p>

<pre>flower1.size.assert == 5
flower2.size.assert == 7</pre>

<p>Like ordinary strings we can concatenate the two strings</p>

<pre>flowers = flower1 + ' ' + flower2
flowers.to_s.assert == &quot;\e[31mRoses\e[0m \e[34mViolets\e[0m&quot;

flowers.size.assert == 13</pre>

<p>Standard case conversion such as #upcase and #downcase work.</p>

<pre>flower1.upcase.to_s.assert == &quot;\e[31mROSES\e[0m&quot;
flower1.downcase.to_s.assert == &quot;\e[31mroses\e[0m&quot;</pre>

<p>Some of the most difficult methods to re-implement were the  substitution
methods such as #sub and #gsub. They are still somewhat more limited than
the original string methods, but their primary functionality should work.</p>

<pre>flower1.gsub('s', 'z').to_s.assert == &quot;\e[31mRozez\e[0m&quot;</pre>

<p>There are still a number of methods that need implementation. ANSI::String
is currently a very partial implementation. But as you can see from the
methods it does currently support, is it already useful.</p>


<h1>ANSI::Columns</h1>

<p>The <tt>Columns</tt> class makes it easy to create nice looking text
columns, sorted from top to bottom, right to left (as opposed to the other
way around).</p>

<pre>require 'ansi/columns'

list = %w{a b c d e f g h i j k l}

columns = ANSI::Columns.new(list)

columns.to_s(4)</pre>

<p>The output will be:</p>

<pre>a d g j
b e h k
c f i l</pre>

<p>Besides and array of elements, Columns.new can take a string in which the
elements are divided by newlines characters. The default column size can
also be given to the initializer.</p>

<pre>list = &quot;a\nb\nc\nd\ne\nf\ng\nh\ni\nj\nk\nl&quot;

columns = ANSI::Columns.new(list, :columns=&gt;6)

columns.to_s</pre>

<p>The output will be:</p>

<pre>a c e g i k
b d f h j l</pre>

<p>If the column count is <tt>nil</tt>, then the number of columns will be
calculated as a best fit for the current terminal window.</p>

<h2>Padding</h2>

<p>Columns can adjsut the padding between cells.</p>

<pre>list = %w{a b c d e f g h i j k l}

columns = ANSI::Columns.new(list, :padding=&gt;2)

columns.to_s(4)</pre>

<p>The output will be:</p>

<pre>a  d  g  j
b  e  h  k
c  f  i  l</pre>

<h2>Alignment</h2>

<p>Columns can also be aligned either left or right.</p>

<pre>list = %w{xx xx xx yy y yy z zz z}

columns = ANSI::Columns.new(list, :align=&gt;:right)

columns.to_s(3)</pre>

<p>The output will be:</p>

<pre>xx yy  z
xx  y zz
xx yy  z</pre>

<h2>Format</h2>

<p>Lastly, columns can be aguamented with ANSI codes. This is done through a
formating block. The block can take upto three parameters, the cell
content, the row and column numbers, or the cell and the row and column
numbers.</p>

<pre>list = %w{a b c d e f g h i j k l}

columns = ANSI::Columns.new(list){ |r,c| c % 2 == 0 ? :red : :blue }

out = columns.to_s(4)

out.assert == (
  &quot;\e[31ma \e[0m\e[31md \e[0m\e[31mg \e[0m\e[31mj \e[0m\n&quot; +
  &quot;\e[34mb \e[0m\e[34me \e[0m\e[34mh \e[0m\e[34mk \e[0m\n&quot; +
  &quot;\e[31mc \e[0m\e[31mf \e[0m\e[31mi \e[0m\e[31ml \e[0m\n&quot;
)</pre>

<p>QED.</p>


<h1>ANSI::Table</h1>

<p>The ANSI::Table class can be used to output tabular data with nicely
formated ASCII cell borders.</p>

<pre>require 'ansi/table'</pre>

<p>The constructor takes an 2-dimensional array.</p>

<pre>data = [
  [ 10, 20, 30 ],
  [ 20, 10, 20 ],
  [ 50, 40, 20 ]
]

table = ANSI::Table.new(data)

table.to_s</pre>

<p>The output will be:</p>

<pre>+----+----+----+
| 10 | 20 | 30 |
| 20 | 10 | 20 |
| 50 | 40 | 20 |
+----+----+----+</pre>


    </div>
  </div>

  <br/><br/><br/>
</body>

</html>

<script src="../assets/scripts/spec.js" type="text/javascript" language="javascript"></script>

<script type="text/javascript" language="javascript">
  /*****************************************************************
   * $.toc()
   * by rebecca murphey
   * rmurphey gmail com
   *
   * This function is called on its own and takes as an argument
   * a list of selectors with which it will build a table of
   * contents. 
   *
   * The first selector will make up the top level of the TOC;
   * the second selector will make up the second level of the TOC;
   * etc.
   *
   * This function returns a div containing nested unordered lists;
   * each list item is linked to an anchor tag added before the item
   * on the page.
   *
   * usage: $.toc('h1,h2,h3').prependTo('body');
   ************************************************************************/
  (function($) { 
    $.toc = function(tocList) {
      $(tocList).addClass('jquery-toc');
      var tocListArray = tocList.split(',');
      $.each(tocListArray, function(i,v) { tocListArray[i] = $.trim(v); });
      var $elements = $('.jquery-toc');
      $('body').append('<div></div>');
      var $toc = $('body div:last');
      var lastLevel = 1;
      $toc.append('<ul class="jquery-toc-1"></ul>');
      $elements.each(function() {
        var $e = $(this);
        var text = $e.text();
        var anchor = text.replace(/ /g,'-');
        $e.before('<a name="' + anchor + '"></a>');
        var level;
        $.each(tocListArray, function(i,v) { 
          if (v.match(' ')) {
            var vArray = v.split(' '); 
            var e = vArray[vArray.length - 1];
          } else { e = v; }
          if ($e.is(e)) { level = i+1; } 
        });
        var className = 'jquery-toc-' + level;
        var li = '<li><a href="#' + anchor + '">' + text + '</a></li>';
        if (level == lastLevel) {
          $('ul.' + className + ':last',$toc).append(li);
        } else if (level > lastLevel) {
          var parentLevel = level - 1;
          var parentClassName = 'jquery-toc-' + parentLevel;
          $('ul.' + parentClassName + ':last',$toc).
            append('<ul class="' + className + '"></ul>');
          $('ul.' + className + ':last',$toc).append(li);
        } else if (level < lastLevel) {
          $('ul.' + className + ':last',$toc).append(li);
        }
        lastLevel = level;
      });
      var $toc_ul = $('ul.jquery-toc-1',$toc);
      $toc.remove();
      return($toc_ul);
   }
  })(jQuery);
</script>

<script>
  function toc_toggle() {
    $('#toc_side').toggle();
    $("pre").addClass("pass");
    $("pre:contains('FAIL:')").addClass("fail");
    $("pre:contains('ERROR:')").addClass("error");
  };

  $.toc('#content h1,h2,h3,h4').appendTo('.toc');

  toc_toggle();
</script>

